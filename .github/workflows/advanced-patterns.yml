# ===================================================
# ADVANCED PATTERNS WORKFLOW EXAMPLE - MODULE 4
# ===================================================
# LEARNING OBJECTIVES:
# - Understand fan-out/fan-in pattern
# - Learn job dependencies and outputs
# - See conditional job execution
# - Implement job output sharing
# ===================================================

name: Advanced Workflow Patterns

on:
  # Manual trigger for easy testing
  workflow_dispatch:
  
  # Automatic trigger on push to main
  push:
    branches: [main]

jobs:
  # ===================================================
  # PATTERN 1: SETUP - Prepares work for parallel jobs
  # ===================================================
  setup:
    name: Setup Test Environment
    runs-on: ubuntu-latest
    # LEARNING POINT: This job prepares data for parallel jobs
    outputs:
      test_data: ${{ steps.prepare.outputs.test_data }}
    
    steps:
      - name: Prepare test data
        id: prepare
        run: |
          echo "Preparing test data for parallel jobs..."
          # Create test data for parallel jobs
          echo 'test_data=["unit","api","ui"]' >> $GITHUB_OUTPUT
          echo "Test data prepared!"

  # ===================================================
  # PATTERN 2: FAN-OUT - Run tests in parallel
  # ===================================================
  test:
    name: Test ${{ matrix.test_type }}
    needs: setup
    runs-on: ubuntu-latest
    # LEARNING POINT: Allow the workflow to continue even if tests fail
    continue-on-error: true
    # LEARNING POINT: Create parallel jobs based on setup output
    strategy:
      matrix:
        test_type: ${{ fromJson(needs.setup.outputs.test_data) }}
      fail-fast: false
    
    # LEARNING POINT: Each parallel job produces an output
    outputs:
      status-${{ matrix.test_type }}: ${{ steps.run-test.outputs.status }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run ${{ matrix.test_type }} tests
        id: run-test
        run: |
          echo "Running ${{ matrix.test_type }} tests..."
          
          # Different behavior based on test type
          if [[ "${{ matrix.test_type }}" == "unit" ]]; then
            # Unit tests always pass
            echo "Unit tests passed!"
            echo "status=passed" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.test_type }}" == "api" ]]; then
            # API tests randomly pass or fail
            if [[ $((RANDOM % 2)) -eq 0 ]]; then
              echo "API tests passed!"
              echo "status=passed" >> $GITHUB_OUTPUT
            else
              echo "API tests failed!"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            # UI tests always fail
            echo "UI tests failed!"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

  # ===================================================
  # PATTERN 3: FAN-IN - Aggregate results from parallel jobs
  # ===================================================
  report:
    name: Aggregate Test Results
    # LEARNING POINT: This job runs after all parallel test jobs complete
    needs: test
    runs-on: ubuntu-latest
    # LEARNING POINT: Run even if some tests failed
    if: always()
    
    steps:
      # LEARNING POINT: Access outputs from all parallel jobs
      - name: Collect test results
        run: |
          echo "Collecting results from all parallel test jobs..."
          
          echo "Test results summary:"
          echo "---------------------"
          echo "Unit tests: ${{ needs.test.outputs['status-unit'] || 'unknown' }}"
          echo "API tests: ${{ needs.test.outputs['status-api'] || 'unknown' }}"
          echo "UI tests: ${{ needs.test.outputs['status-ui'] || 'unknown' }}"
          
          # Check if any job failed
          if [[ "${{ contains(needs.test.result, 'failure') }}" == "true" ]]; then
            echo "❌ Some tests failed"
          else
            echo "✅ All tests passed"
          fi

  # ===================================================
  # PATTERN 4: CONDITIONAL EXECUTION
  # ===================================================
  deploy-staging:
    name: Deploy to Staging
    needs: [test, report]
    runs-on: ubuntu-latest
    # LEARNING POINT: Always deploy to staging, even if tests fail
    if: always()
    
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          echo "Staging deployment successful!"

  deploy-production:
    name: Deploy to Production
    needs: [test, report]
    runs-on: ubuntu-latest
    # LEARNING POINT: Only deploy to production if all tests pass
    if: needs.test.result == 'success'
    
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          echo "Production deployment successful!"

# ===================================================
# LEARNING NOTES:
# ===================================================
# 1. Fan-out/fan-in pattern:
#    - Setup job prepares data (fan-out preparation)
#    - Test jobs run in parallel (fan-out execution)
#    - Report job collects results (fan-in)
# 2. Dynamic matrix creation from job outputs
# 3. Job outputs can be shared between jobs
# 4. continue-on-error allows the workflow to proceed even when tests fail
# 5. Conditional execution controls when jobs should run
# 6. The 'always()' function ensures jobs run regardless of previous job status
# 7. The 'needs' keyword creates job dependencies
# ===================================================
