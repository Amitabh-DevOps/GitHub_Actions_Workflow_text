# ===================================================
# ADVANCED PATTERNS WORKFLOW EXAMPLE - MODULE 4
# ===================================================
# LEARNING OBJECTIVES:
# - Understand fan-out/fan-in pattern
# - Learn job dependencies and outputs
# - See conditional job execution
# - Implement job output sharing
# ===================================================

name: Advanced Workflow Patterns

on:
  # Manual trigger for easy testing
  workflow_dispatch:
  
  # Automatic trigger on push to main
  push:
    branches: [main]

jobs:
  # ===================================================
  # PATTERN 1: RANDOM TEST OUTCOME
  # ===================================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    # LEARNING POINT: Allow the workflow to continue even if the test fails
    continue-on-error: true
    # LEARNING POINT: Job produces an output
    outputs:
      status: ${{ steps.run-tests.outputs.status }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Run tests
        id: run-tests
        run: |
          echo "Running tests..."
          
          # Randomly pass or fail based on a coin flip
          if [[ $((RANDOM % 2)) -eq 0 ]]; then
            echo "Tests passed!"
            echo "status=passed" >> $GITHUB_OUTPUT
          else
            echo "Tests failed!"
            echo "status=failed" >> $GITHUB_OUTPUT
            # Force an error to ensure this job fails
            exit 1
          fi

  # ===================================================
  # PATTERN 2: RESULT REPORTING
  # ===================================================
  report:
    name: Report Test Results
    # LEARNING POINT: This job runs after the test job completes
    needs: test
    runs-on: ubuntu-latest
    # LEARNING POINT: Run even if the test failed
    if: always()
    
    steps:
      # LEARNING POINT: Access outputs from the test job
      - name: Check test results
        run: |
          echo "Test results summary:"
          echo "---------------------"
          echo "Test status: ${{ needs.test.outputs.status }}"
          
          # Check if the test job failed
          if [[ "${{ needs.test.result }}" == "failure" ]]; then
            echo "❌ Tests failed"
          else
            echo "✅ Tests passed"
          fi

  # ===================================================
  # PATTERN 3: CONDITIONAL EXECUTION
  # ===================================================
  deploy-staging:
    name: Deploy to Staging
    needs: [test, report]
    runs-on: ubuntu-latest
    # LEARNING POINT: Always deploy to staging, even if tests fail
    if: always()
    
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          echo "Staging deployment successful!"

  deploy-production:
    name: Deploy to Production
    needs: [test, report]
    runs-on: ubuntu-latest
    # LEARNING POINT: Only deploy to production if tests pass
    if: needs.test.result == 'success'
    
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          echo "Production deployment successful!"

# ===================================================
# LEARNING NOTES:
# ===================================================
# 1. Random outcomes demonstrate how workflows handle success and failure
# 2. Job outputs can be shared between jobs using needs.<job>.outputs
# 3. continue-on-error allows the workflow to proceed even when tests fail
# 4. Conditional execution controls when jobs should run
# 5. The 'always()' function ensures jobs run regardless of previous job status
# 6. The 'needs' keyword creates job dependencies
# 7. The job.result value can be checked to determine if a job succeeded or failed
# ===================================================
